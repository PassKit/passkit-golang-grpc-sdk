//*
// This protocol is suit for cases where the business logic is handled elsewhere, and the purpose is purely to issue and
// update content for Apple Wallet and Google Pay.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0
// source: io/raw/a_rpc.proto

package raw

import (
	context "context"
	io "github.com/PassKit/passkit-golang-grpc-sdk/io"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Raw_CreatePassProject_FullMethodName        = "/raw.Raw/createPassProject"
	Raw_UpdatePassProject_FullMethodName        = "/raw.Raw/updatePassProject"
	Raw_GetPassProject_FullMethodName           = "/raw.Raw/getPassProject"
	Raw_CopyPassProject_FullMethodName          = "/raw.Raw/copyPassProject"
	Raw_DeletePassProject_FullMethodName        = "/raw.Raw/deletePassProject"
	Raw_CreatePass_FullMethodName               = "/raw.Raw/createPass"
	Raw_UpdatePass_FullMethodName               = "/raw.Raw/updatePass"
	Raw_StreamPassUpdates_FullMethodName        = "/raw.Raw/streamPassUpdates"
	Raw_GetPassById_FullMethodName              = "/raw.Raw/getPassById"
	Raw_GetPassByExternalId_FullMethodName      = "/raw.Raw/getPassByExternalId"
	Raw_DeletePass_FullMethodName               = "/raw.Raw/deletePass"
	Raw_ListPassesByPassProject_FullMethodName  = "/raw.Raw/listPassesByPassProject"
	Raw_ListPassesByPassTemplate_FullMethodName = "/raw.Raw/listPassesByPassTemplate"
)

// RawClient is the client API for Raw service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RawClient interface {
	CreatePassProject(ctx context.Context, in *PassProject, opts ...grpc.CallOption) (*io.Id, error)
	UpdatePassProject(ctx context.Context, in *PassProject, opts ...grpc.CallOption) (*PassProject, error)
	GetPassProject(ctx context.Context, in *io.Id, opts ...grpc.CallOption) (*PassProject, error)
	CopyPassProject(ctx context.Context, in *PassProjectCopyRequest, opts ...grpc.CallOption) (*io.Id, error)
	DeletePassProject(ctx context.Context, in *io.Id, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreatePass(ctx context.Context, in *Pass, opts ...grpc.CallOption) (*io.Id, error)
	UpdatePass(ctx context.Context, in *Pass, opts ...grpc.CallOption) (*io.Id, error)
	StreamPassUpdates(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Pass, io.Id], error)
	GetPassById(ctx context.Context, in *io.Id, opts ...grpc.CallOption) (*Pass, error)
	GetPassByExternalId(ctx context.Context, in *PassRecordByExternalIdRequest, opts ...grpc.CallOption) (*Pass, error)
	DeletePass(ctx context.Context, in *Pass, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListPassesByPassProject(ctx context.Context, in *ListPassesByPassProjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Pass], error)
	ListPassesByPassTemplate(ctx context.Context, in *ListPassesByPassTemplateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Pass], error)
}

type rawClient struct {
	cc grpc.ClientConnInterface
}

func NewRawClient(cc grpc.ClientConnInterface) RawClient {
	return &rawClient{cc}
}

func (c *rawClient) CreatePassProject(ctx context.Context, in *PassProject, opts ...grpc.CallOption) (*io.Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(io.Id)
	err := c.cc.Invoke(ctx, Raw_CreatePassProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) UpdatePassProject(ctx context.Context, in *PassProject, opts ...grpc.CallOption) (*PassProject, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PassProject)
	err := c.cc.Invoke(ctx, Raw_UpdatePassProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) GetPassProject(ctx context.Context, in *io.Id, opts ...grpc.CallOption) (*PassProject, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PassProject)
	err := c.cc.Invoke(ctx, Raw_GetPassProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) CopyPassProject(ctx context.Context, in *PassProjectCopyRequest, opts ...grpc.CallOption) (*io.Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(io.Id)
	err := c.cc.Invoke(ctx, Raw_CopyPassProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) DeletePassProject(ctx context.Context, in *io.Id, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Raw_DeletePassProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) CreatePass(ctx context.Context, in *Pass, opts ...grpc.CallOption) (*io.Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(io.Id)
	err := c.cc.Invoke(ctx, Raw_CreatePass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) UpdatePass(ctx context.Context, in *Pass, opts ...grpc.CallOption) (*io.Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(io.Id)
	err := c.cc.Invoke(ctx, Raw_UpdatePass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) StreamPassUpdates(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[Pass, io.Id], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Raw_ServiceDesc.Streams[0], Raw_StreamPassUpdates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Pass, io.Id]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Raw_StreamPassUpdatesClient = grpc.BidiStreamingClient[Pass, io.Id]

func (c *rawClient) GetPassById(ctx context.Context, in *io.Id, opts ...grpc.CallOption) (*Pass, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pass)
	err := c.cc.Invoke(ctx, Raw_GetPassById_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) GetPassByExternalId(ctx context.Context, in *PassRecordByExternalIdRequest, opts ...grpc.CallOption) (*Pass, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pass)
	err := c.cc.Invoke(ctx, Raw_GetPassByExternalId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) DeletePass(ctx context.Context, in *Pass, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Raw_DeletePass_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rawClient) ListPassesByPassProject(ctx context.Context, in *ListPassesByPassProjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Pass], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Raw_ServiceDesc.Streams[1], Raw_ListPassesByPassProject_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListPassesByPassProjectRequest, Pass]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Raw_ListPassesByPassProjectClient = grpc.ServerStreamingClient[Pass]

func (c *rawClient) ListPassesByPassTemplate(ctx context.Context, in *ListPassesByPassTemplateRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Pass], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Raw_ServiceDesc.Streams[2], Raw_ListPassesByPassTemplate_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListPassesByPassTemplateRequest, Pass]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Raw_ListPassesByPassTemplateClient = grpc.ServerStreamingClient[Pass]

// RawServer is the server API for Raw service.
// All implementations should embed UnimplementedRawServer
// for forward compatibility.
type RawServer interface {
	CreatePassProject(context.Context, *PassProject) (*io.Id, error)
	UpdatePassProject(context.Context, *PassProject) (*PassProject, error)
	GetPassProject(context.Context, *io.Id) (*PassProject, error)
	CopyPassProject(context.Context, *PassProjectCopyRequest) (*io.Id, error)
	DeletePassProject(context.Context, *io.Id) (*emptypb.Empty, error)
	CreatePass(context.Context, *Pass) (*io.Id, error)
	UpdatePass(context.Context, *Pass) (*io.Id, error)
	StreamPassUpdates(grpc.BidiStreamingServer[Pass, io.Id]) error
	GetPassById(context.Context, *io.Id) (*Pass, error)
	GetPassByExternalId(context.Context, *PassRecordByExternalIdRequest) (*Pass, error)
	DeletePass(context.Context, *Pass) (*emptypb.Empty, error)
	ListPassesByPassProject(*ListPassesByPassProjectRequest, grpc.ServerStreamingServer[Pass]) error
	ListPassesByPassTemplate(*ListPassesByPassTemplateRequest, grpc.ServerStreamingServer[Pass]) error
}

// UnimplementedRawServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRawServer struct{}

func (UnimplementedRawServer) CreatePassProject(context.Context, *PassProject) (*io.Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePassProject not implemented")
}
func (UnimplementedRawServer) UpdatePassProject(context.Context, *PassProject) (*PassProject, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePassProject not implemented")
}
func (UnimplementedRawServer) GetPassProject(context.Context, *io.Id) (*PassProject, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPassProject not implemented")
}
func (UnimplementedRawServer) CopyPassProject(context.Context, *PassProjectCopyRequest) (*io.Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyPassProject not implemented")
}
func (UnimplementedRawServer) DeletePassProject(context.Context, *io.Id) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePassProject not implemented")
}
func (UnimplementedRawServer) CreatePass(context.Context, *Pass) (*io.Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePass not implemented")
}
func (UnimplementedRawServer) UpdatePass(context.Context, *Pass) (*io.Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePass not implemented")
}
func (UnimplementedRawServer) StreamPassUpdates(grpc.BidiStreamingServer[Pass, io.Id]) error {
	return status.Errorf(codes.Unimplemented, "method StreamPassUpdates not implemented")
}
func (UnimplementedRawServer) GetPassById(context.Context, *io.Id) (*Pass, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPassById not implemented")
}
func (UnimplementedRawServer) GetPassByExternalId(context.Context, *PassRecordByExternalIdRequest) (*Pass, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPassByExternalId not implemented")
}
func (UnimplementedRawServer) DeletePass(context.Context, *Pass) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePass not implemented")
}
func (UnimplementedRawServer) ListPassesByPassProject(*ListPassesByPassProjectRequest, grpc.ServerStreamingServer[Pass]) error {
	return status.Errorf(codes.Unimplemented, "method ListPassesByPassProject not implemented")
}
func (UnimplementedRawServer) ListPassesByPassTemplate(*ListPassesByPassTemplateRequest, grpc.ServerStreamingServer[Pass]) error {
	return status.Errorf(codes.Unimplemented, "method ListPassesByPassTemplate not implemented")
}
func (UnimplementedRawServer) testEmbeddedByValue() {}

// UnsafeRawServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RawServer will
// result in compilation errors.
type UnsafeRawServer interface {
	mustEmbedUnimplementedRawServer()
}

func RegisterRawServer(s grpc.ServiceRegistrar, srv RawServer) {
	// If the following call pancis, it indicates UnimplementedRawServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Raw_ServiceDesc, srv)
}

func _Raw_CreatePassProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PassProject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).CreatePassProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_CreatePassProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).CreatePassProject(ctx, req.(*PassProject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_UpdatePassProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PassProject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).UpdatePassProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_UpdatePassProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).UpdatePassProject(ctx, req.(*PassProject))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_GetPassProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(io.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).GetPassProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_GetPassProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).GetPassProject(ctx, req.(*io.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_CopyPassProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PassProjectCopyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).CopyPassProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_CopyPassProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).CopyPassProject(ctx, req.(*PassProjectCopyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_DeletePassProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(io.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).DeletePassProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_DeletePassProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).DeletePassProject(ctx, req.(*io.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_CreatePass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).CreatePass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_CreatePass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).CreatePass(ctx, req.(*Pass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_UpdatePass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).UpdatePass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_UpdatePass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).UpdatePass(ctx, req.(*Pass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_StreamPassUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RawServer).StreamPassUpdates(&grpc.GenericServerStream[Pass, io.Id]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Raw_StreamPassUpdatesServer = grpc.BidiStreamingServer[Pass, io.Id]

func _Raw_GetPassById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(io.Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).GetPassById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_GetPassById_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).GetPassById(ctx, req.(*io.Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_GetPassByExternalId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PassRecordByExternalIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).GetPassByExternalId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_GetPassByExternalId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).GetPassByExternalId(ctx, req.(*PassRecordByExternalIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_DeletePass_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Pass)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RawServer).DeletePass(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Raw_DeletePass_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RawServer).DeletePass(ctx, req.(*Pass))
	}
	return interceptor(ctx, in, info, handler)
}

func _Raw_ListPassesByPassProject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListPassesByPassProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RawServer).ListPassesByPassProject(m, &grpc.GenericServerStream[ListPassesByPassProjectRequest, Pass]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Raw_ListPassesByPassProjectServer = grpc.ServerStreamingServer[Pass]

func _Raw_ListPassesByPassTemplate_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListPassesByPassTemplateRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RawServer).ListPassesByPassTemplate(m, &grpc.GenericServerStream[ListPassesByPassTemplateRequest, Pass]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Raw_ListPassesByPassTemplateServer = grpc.ServerStreamingServer[Pass]

// Raw_ServiceDesc is the grpc.ServiceDesc for Raw service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Raw_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "raw.Raw",
	HandlerType: (*RawServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createPassProject",
			Handler:    _Raw_CreatePassProject_Handler,
		},
		{
			MethodName: "updatePassProject",
			Handler:    _Raw_UpdatePassProject_Handler,
		},
		{
			MethodName: "getPassProject",
			Handler:    _Raw_GetPassProject_Handler,
		},
		{
			MethodName: "copyPassProject",
			Handler:    _Raw_CopyPassProject_Handler,
		},
		{
			MethodName: "deletePassProject",
			Handler:    _Raw_DeletePassProject_Handler,
		},
		{
			MethodName: "createPass",
			Handler:    _Raw_CreatePass_Handler,
		},
		{
			MethodName: "updatePass",
			Handler:    _Raw_UpdatePass_Handler,
		},
		{
			MethodName: "getPassById",
			Handler:    _Raw_GetPassById_Handler,
		},
		{
			MethodName: "getPassByExternalId",
			Handler:    _Raw_GetPassByExternalId_Handler,
		},
		{
			MethodName: "deletePass",
			Handler:    _Raw_DeletePass_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "streamPassUpdates",
			Handler:       _Raw_StreamPassUpdates_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "listPassesByPassProject",
			Handler:       _Raw_ListPassesByPassProject_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listPassesByPassTemplate",
			Handler:       _Raw_ListPassesByPassTemplate_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/raw/a_rpc.proto",
}
