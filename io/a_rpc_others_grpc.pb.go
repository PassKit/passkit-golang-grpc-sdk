// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.0
// source: io/core/a_rpc_others.proto

package io

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Users_CreateUser_FullMethodName                        = "/io.Users/createUser"
	Users_NewUser_FullMethodName                           = "/io.Users/newUser"
	Users_Verify_FullMethodName                            = "/io.Users/verify"
	Users_ResendVerificationEmail_FullMethodName           = "/io.Users/resendVerificationEmail"
	Users_GetUser_FullMethodName                           = "/io.Users/getUser"
	Users_Login_FullMethodName                             = "/io.Users/login"
	Users_Get2FaBarcode_FullMethodName                     = "/io.Users/get2faBarcode"
	Users_ResetPassword_FullMethodName                     = "/io.Users/resetPassword"
	Users_SendPasswordResetLink_FullMethodName             = "/io.Users/sendPasswordResetLink"
	Users_ChangePassword_FullMethodName                    = "/io.Users/changePassword"
	Users_ChangeEmail_FullMethodName                       = "/io.Users/changeEmail"
	Users_ConfirmEmailChange_FullMethodName                = "/io.Users/confirmEmailChange"
	Users_UpdateCompanyName_FullMethodName                 = "/io.Users/updateCompanyName"
	Users_GetProjectsForUserQueryDeprecated_FullMethodName = "/io.Users/getProjectsForUserQueryDeprecated"
	Users_GetProjectsQueryDeprecated_FullMethodName        = "/io.Users/getProjectsQueryDeprecated"
	Users_GetProjectsForUserQuery_FullMethodName           = "/io.Users/getProjectsForUserQuery"
	Users_GetProjectsQuery_FullMethodName                  = "/io.Users/getProjectsQuery"
	Users_GetProjectByUuid_FullMethodName                  = "/io.Users/getProjectByUuid"
	Users_GetProjectAndTemplateByShortCode_FullMethodName  = "/io.Users/getProjectAndTemplateByShortCode"
	Users_GetProjectsForUser_FullMethodName                = "/io.Users/getProjectsForUser"
	Users_GetProjects_FullMethodName                       = "/io.Users/getProjects"
	Users_GetScannerConfig_FullMethodName                  = "/io.Users/getScannerConfig"
	Users_CreateScannerConfig_FullMethodName               = "/io.Users/createScannerConfig"
	Users_UpdateScannerConfig_FullMethodName               = "/io.Users/updateScannerConfig"
	Users_CreateAuthorizationResource_FullMethodName       = "/io.Users/createAuthorizationResource"
	Users_DeleteAuthorizationResource_FullMethodName       = "/io.Users/deleteAuthorizationResource"
	Users_RefreshApiSecret_FullMethodName                  = "/io.Users/refreshApiSecret"
	Users_DeleteAccount_FullMethodName                     = "/io.Users/deleteAccount"
	Users_RevokeLegacyCredentials_FullMethodName           = "/io.Users/revokeLegacyCredentials"
	Users_CreateTeamMember_FullMethodName                  = "/io.Users/createTeamMember"
	Users_CreatePermissionsForTeamMember_FullMethodName    = "/io.Users/createPermissionsForTeamMember"
	Users_UpdateTeamMemberPermissions_FullMethodName       = "/io.Users/updateTeamMemberPermissions"
	Users_PatchTeamMemberPermissions_FullMethodName        = "/io.Users/patchTeamMemberPermissions"
	Users_GetTeamMember_FullMethodName                     = "/io.Users/getTeamMember"
	Users_GetTeamMembers_FullMethodName                    = "/io.Users/getTeamMembers"
	Users_DeleteTeamMember_FullMethodName                  = "/io.Users/deleteTeamMember"
	Users_GetTeamMemberLogs_FullMethodName                 = "/io.Users/getTeamMemberLogs"
)

// UsersClient is the client API for Users service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UsersClient interface {
	CreateUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*NewUserResponse, error)
	NewUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*JWT, error)
	Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*Boolean, error)
	ResendVerificationEmail(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Boolean, error)
	GetUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetUserResponse, error)
	Login(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*JWT, error)
	Get2FaBarcode(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Url, error)
	ResetPassword(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SendPasswordResetLink(ctx context.Context, in *Username, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ChangePassword(ctx context.Context, in *PasswordResetInput, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ChangeEmail(ctx context.Context, in *Email, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ConfirmEmailChange(ctx context.Context, in *ConfirmEmailChangeInput, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateCompanyName(ctx context.Context, in *CompanyName, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetProjectsForUserQueryDeprecated(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error)
	GetProjectsQueryDeprecated(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error)
	GetProjectsForUserQuery(ctx context.Context, in *Filters, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error)
	GetProjectsQuery(ctx context.Context, in *Filters, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error)
	GetProjectByUuid(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Project, error)
	GetProjectAndTemplateByShortCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ProjectByShortCodeResult, error)
	GetProjectsForUser(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error)
	GetProjects(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error)
	GetScannerConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ScannerConfiguration, error)
	CreateScannerConfig(ctx context.Context, in *ScannerConfiguration, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateScannerConfig(ctx context.Context, in *ScannerConfiguration, opts ...grpc.CallOption) (*ScannerConfiguration, error)
	// Creates a new oauth2 resource, the returned id is NOT the access token used to make requests on the users behalf.
	CreateAuthorizationResource(ctx context.Context, in *OAuth2AuthorizationRequest, opts ...grpc.CallOption) (*Id, error)
	DeleteAuthorizationResource(ctx context.Context, in *Id, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RefreshApiSecret(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	RevokeLegacyCredentials(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Team Members
	CreateTeamMember(ctx context.Context, in *NewTeamMember, opts ...grpc.CallOption) (*Id, error)
	CreatePermissionsForTeamMember(ctx context.Context, in *TeamMemberPermissions, opts ...grpc.CallOption) (*Id, error)
	UpdateTeamMemberPermissions(ctx context.Context, in *TeamMemberPermissions, opts ...grpc.CallOption) (*TeamMemberPermissions, error)
	PatchTeamMemberPermissions(ctx context.Context, in *TeamMemberPermissions, opts ...grpc.CallOption) (*TeamMemberPermissions, error)
	GetTeamMember(ctx context.Context, in *Id, opts ...grpc.CallOption) (*GetTeamMemberResponse, error)
	GetTeamMembers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ListTeamMembersResponse], error)
	DeleteTeamMember(ctx context.Context, in *Id, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetTeamMemberLogs(ctx context.Context, in *AuditLogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AuditLog], error)
}

type usersClient struct {
	cc grpc.ClientConnInterface
}

func NewUsersClient(cc grpc.ClientConnInterface) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) CreateUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*NewUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(NewUserResponse)
	err := c.cc.Invoke(ctx, Users_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) NewUser(ctx context.Context, in *NewUser, opts ...grpc.CallOption) (*JWT, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JWT)
	err := c.cc.Invoke(ctx, Users_NewUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Verify(ctx context.Context, in *VerifyRequest, opts ...grpc.CallOption) (*Boolean, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Boolean)
	err := c.cc.Invoke(ctx, Users_Verify_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ResendVerificationEmail(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Boolean, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Boolean)
	err := c.cc.Invoke(ctx, Users_ResendVerificationEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetUser(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetUserResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserResponse)
	err := c.cc.Invoke(ctx, Users_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Login(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*JWT, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JWT)
	err := c.cc.Invoke(ctx, Users_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) Get2FaBarcode(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Url, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Url)
	err := c.cc.Invoke(ctx, Users_Get2FaBarcode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ResetPassword(ctx context.Context, in *Credentials, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_ResetPassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) SendPasswordResetLink(ctx context.Context, in *Username, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_SendPasswordResetLink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ChangePassword(ctx context.Context, in *PasswordResetInput, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_ChangePassword_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ChangeEmail(ctx context.Context, in *Email, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_ChangeEmail_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ConfirmEmailChange(ctx context.Context, in *ConfirmEmailChangeInput, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_ConfirmEmailChange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) UpdateCompanyName(ctx context.Context, in *CompanyName, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_UpdateCompanyName_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetProjectsForUserQueryDeprecated(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Users_ServiceDesc.Streams[0], Users_GetProjectsForUserQueryDeprecated_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Pagination, Project]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsForUserQueryDeprecatedClient = grpc.ServerStreamingClient[Project]

func (c *usersClient) GetProjectsQueryDeprecated(ctx context.Context, in *Pagination, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Users_ServiceDesc.Streams[1], Users_GetProjectsQueryDeprecated_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Pagination, Project]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsQueryDeprecatedClient = grpc.ServerStreamingClient[Project]

func (c *usersClient) GetProjectsForUserQuery(ctx context.Context, in *Filters, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Users_ServiceDesc.Streams[2], Users_GetProjectsForUserQuery_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Filters, Project]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsForUserQueryClient = grpc.ServerStreamingClient[Project]

func (c *usersClient) GetProjectsQuery(ctx context.Context, in *Filters, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Users_ServiceDesc.Streams[3], Users_GetProjectsQuery_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[Filters, Project]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsQueryClient = grpc.ServerStreamingClient[Project]

func (c *usersClient) GetProjectByUuid(ctx context.Context, in *Id, opts ...grpc.CallOption) (*Project, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Project)
	err := c.cc.Invoke(ctx, Users_GetProjectByUuid_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetProjectAndTemplateByShortCode(ctx context.Context, in *Id, opts ...grpc.CallOption) (*ProjectByShortCodeResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectByShortCodeResult)
	err := c.cc.Invoke(ctx, Users_GetProjectAndTemplateByShortCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetProjectsForUser(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Users_ServiceDesc.Streams[4], Users_GetProjectsForUser_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ProjectStatusFilter, Project]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsForUserClient = grpc.ServerStreamingClient[Project]

func (c *usersClient) GetProjects(ctx context.Context, in *ProjectStatusFilter, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Project], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Users_ServiceDesc.Streams[5], Users_GetProjects_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ProjectStatusFilter, Project]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsClient = grpc.ServerStreamingClient[Project]

func (c *usersClient) GetScannerConfig(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ScannerConfiguration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScannerConfiguration)
	err := c.cc.Invoke(ctx, Users_GetScannerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) CreateScannerConfig(ctx context.Context, in *ScannerConfiguration, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_CreateScannerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) UpdateScannerConfig(ctx context.Context, in *ScannerConfiguration, opts ...grpc.CallOption) (*ScannerConfiguration, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ScannerConfiguration)
	err := c.cc.Invoke(ctx, Users_UpdateScannerConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) CreateAuthorizationResource(ctx context.Context, in *OAuth2AuthorizationRequest, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, Users_CreateAuthorizationResource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) DeleteAuthorizationResource(ctx context.Context, in *Id, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_DeleteAuthorizationResource_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) RefreshApiSecret(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_RefreshApiSecret_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_DeleteAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) RevokeLegacyCredentials(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_RevokeLegacyCredentials_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) CreateTeamMember(ctx context.Context, in *NewTeamMember, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, Users_CreateTeamMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) CreatePermissionsForTeamMember(ctx context.Context, in *TeamMemberPermissions, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, Users_CreatePermissionsForTeamMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) UpdateTeamMemberPermissions(ctx context.Context, in *TeamMemberPermissions, opts ...grpc.CallOption) (*TeamMemberPermissions, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TeamMemberPermissions)
	err := c.cc.Invoke(ctx, Users_UpdateTeamMemberPermissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) PatchTeamMemberPermissions(ctx context.Context, in *TeamMemberPermissions, opts ...grpc.CallOption) (*TeamMemberPermissions, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TeamMemberPermissions)
	err := c.cc.Invoke(ctx, Users_PatchTeamMemberPermissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetTeamMember(ctx context.Context, in *Id, opts ...grpc.CallOption) (*GetTeamMemberResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTeamMemberResponse)
	err := c.cc.Invoke(ctx, Users_GetTeamMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetTeamMembers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ListTeamMembersResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Users_ServiceDesc.Streams[6], Users_GetTeamMembers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, ListTeamMembersResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetTeamMembersClient = grpc.ServerStreamingClient[ListTeamMembersResponse]

func (c *usersClient) DeleteTeamMember(ctx context.Context, in *Id, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Users_DeleteTeamMember_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) GetTeamMemberLogs(ctx context.Context, in *AuditLogRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AuditLog], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Users_ServiceDesc.Streams[7], Users_GetTeamMemberLogs_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AuditLogRequest, AuditLog]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetTeamMemberLogsClient = grpc.ServerStreamingClient[AuditLog]

// UsersServer is the server API for Users service.
// All implementations should embed UnimplementedUsersServer
// for forward compatibility.
type UsersServer interface {
	CreateUser(context.Context, *NewUser) (*NewUserResponse, error)
	NewUser(context.Context, *NewUser) (*JWT, error)
	Verify(context.Context, *VerifyRequest) (*Boolean, error)
	ResendVerificationEmail(context.Context, *emptypb.Empty) (*Boolean, error)
	GetUser(context.Context, *emptypb.Empty) (*GetUserResponse, error)
	Login(context.Context, *Credentials) (*JWT, error)
	Get2FaBarcode(context.Context, *emptypb.Empty) (*Url, error)
	ResetPassword(context.Context, *Credentials) (*emptypb.Empty, error)
	SendPasswordResetLink(context.Context, *Username) (*emptypb.Empty, error)
	ChangePassword(context.Context, *PasswordResetInput) (*emptypb.Empty, error)
	ChangeEmail(context.Context, *Email) (*emptypb.Empty, error)
	ConfirmEmailChange(context.Context, *ConfirmEmailChangeInput) (*emptypb.Empty, error)
	UpdateCompanyName(context.Context, *CompanyName) (*emptypb.Empty, error)
	GetProjectsForUserQueryDeprecated(*Pagination, grpc.ServerStreamingServer[Project]) error
	GetProjectsQueryDeprecated(*Pagination, grpc.ServerStreamingServer[Project]) error
	GetProjectsForUserQuery(*Filters, grpc.ServerStreamingServer[Project]) error
	GetProjectsQuery(*Filters, grpc.ServerStreamingServer[Project]) error
	GetProjectByUuid(context.Context, *Id) (*Project, error)
	GetProjectAndTemplateByShortCode(context.Context, *Id) (*ProjectByShortCodeResult, error)
	GetProjectsForUser(*ProjectStatusFilter, grpc.ServerStreamingServer[Project]) error
	GetProjects(*ProjectStatusFilter, grpc.ServerStreamingServer[Project]) error
	GetScannerConfig(context.Context, *emptypb.Empty) (*ScannerConfiguration, error)
	CreateScannerConfig(context.Context, *ScannerConfiguration) (*emptypb.Empty, error)
	UpdateScannerConfig(context.Context, *ScannerConfiguration) (*ScannerConfiguration, error)
	// Creates a new oauth2 resource, the returned id is NOT the access token used to make requests on the users behalf.
	CreateAuthorizationResource(context.Context, *OAuth2AuthorizationRequest) (*Id, error)
	DeleteAuthorizationResource(context.Context, *Id) (*emptypb.Empty, error)
	RefreshApiSecret(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	DeleteAccount(context.Context, *DeleteAccountRequest) (*emptypb.Empty, error)
	RevokeLegacyCredentials(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Team Members
	CreateTeamMember(context.Context, *NewTeamMember) (*Id, error)
	CreatePermissionsForTeamMember(context.Context, *TeamMemberPermissions) (*Id, error)
	UpdateTeamMemberPermissions(context.Context, *TeamMemberPermissions) (*TeamMemberPermissions, error)
	PatchTeamMemberPermissions(context.Context, *TeamMemberPermissions) (*TeamMemberPermissions, error)
	GetTeamMember(context.Context, *Id) (*GetTeamMemberResponse, error)
	GetTeamMembers(*emptypb.Empty, grpc.ServerStreamingServer[ListTeamMembersResponse]) error
	DeleteTeamMember(context.Context, *Id) (*emptypb.Empty, error)
	GetTeamMemberLogs(*AuditLogRequest, grpc.ServerStreamingServer[AuditLog]) error
}

// UnimplementedUsersServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUsersServer struct{}

func (UnimplementedUsersServer) CreateUser(context.Context, *NewUser) (*NewUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUsersServer) NewUser(context.Context, *NewUser) (*JWT, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewUser not implemented")
}
func (UnimplementedUsersServer) Verify(context.Context, *VerifyRequest) (*Boolean, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Verify not implemented")
}
func (UnimplementedUsersServer) ResendVerificationEmail(context.Context, *emptypb.Empty) (*Boolean, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResendVerificationEmail not implemented")
}
func (UnimplementedUsersServer) GetUser(context.Context, *emptypb.Empty) (*GetUserResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUsersServer) Login(context.Context, *Credentials) (*JWT, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUsersServer) Get2FaBarcode(context.Context, *emptypb.Empty) (*Url, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get2FaBarcode not implemented")
}
func (UnimplementedUsersServer) ResetPassword(context.Context, *Credentials) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetPassword not implemented")
}
func (UnimplementedUsersServer) SendPasswordResetLink(context.Context, *Username) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPasswordResetLink not implemented")
}
func (UnimplementedUsersServer) ChangePassword(context.Context, *PasswordResetInput) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangePassword not implemented")
}
func (UnimplementedUsersServer) ChangeEmail(context.Context, *Email) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeEmail not implemented")
}
func (UnimplementedUsersServer) ConfirmEmailChange(context.Context, *ConfirmEmailChangeInput) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmEmailChange not implemented")
}
func (UnimplementedUsersServer) UpdateCompanyName(context.Context, *CompanyName) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCompanyName not implemented")
}
func (UnimplementedUsersServer) GetProjectsForUserQueryDeprecated(*Pagination, grpc.ServerStreamingServer[Project]) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsForUserQueryDeprecated not implemented")
}
func (UnimplementedUsersServer) GetProjectsQueryDeprecated(*Pagination, grpc.ServerStreamingServer[Project]) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsQueryDeprecated not implemented")
}
func (UnimplementedUsersServer) GetProjectsForUserQuery(*Filters, grpc.ServerStreamingServer[Project]) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsForUserQuery not implemented")
}
func (UnimplementedUsersServer) GetProjectsQuery(*Filters, grpc.ServerStreamingServer[Project]) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsQuery not implemented")
}
func (UnimplementedUsersServer) GetProjectByUuid(context.Context, *Id) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectByUuid not implemented")
}
func (UnimplementedUsersServer) GetProjectAndTemplateByShortCode(context.Context, *Id) (*ProjectByShortCodeResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProjectAndTemplateByShortCode not implemented")
}
func (UnimplementedUsersServer) GetProjectsForUser(*ProjectStatusFilter, grpc.ServerStreamingServer[Project]) error {
	return status.Errorf(codes.Unimplemented, "method GetProjectsForUser not implemented")
}
func (UnimplementedUsersServer) GetProjects(*ProjectStatusFilter, grpc.ServerStreamingServer[Project]) error {
	return status.Errorf(codes.Unimplemented, "method GetProjects not implemented")
}
func (UnimplementedUsersServer) GetScannerConfig(context.Context, *emptypb.Empty) (*ScannerConfiguration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScannerConfig not implemented")
}
func (UnimplementedUsersServer) CreateScannerConfig(context.Context, *ScannerConfiguration) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateScannerConfig not implemented")
}
func (UnimplementedUsersServer) UpdateScannerConfig(context.Context, *ScannerConfiguration) (*ScannerConfiguration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScannerConfig not implemented")
}
func (UnimplementedUsersServer) CreateAuthorizationResource(context.Context, *OAuth2AuthorizationRequest) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAuthorizationResource not implemented")
}
func (UnimplementedUsersServer) DeleteAuthorizationResource(context.Context, *Id) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAuthorizationResource not implemented")
}
func (UnimplementedUsersServer) RefreshApiSecret(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshApiSecret not implemented")
}
func (UnimplementedUsersServer) DeleteAccount(context.Context, *DeleteAccountRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccount not implemented")
}
func (UnimplementedUsersServer) RevokeLegacyCredentials(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeLegacyCredentials not implemented")
}
func (UnimplementedUsersServer) CreateTeamMember(context.Context, *NewTeamMember) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTeamMember not implemented")
}
func (UnimplementedUsersServer) CreatePermissionsForTeamMember(context.Context, *TeamMemberPermissions) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePermissionsForTeamMember not implemented")
}
func (UnimplementedUsersServer) UpdateTeamMemberPermissions(context.Context, *TeamMemberPermissions) (*TeamMemberPermissions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTeamMemberPermissions not implemented")
}
func (UnimplementedUsersServer) PatchTeamMemberPermissions(context.Context, *TeamMemberPermissions) (*TeamMemberPermissions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchTeamMemberPermissions not implemented")
}
func (UnimplementedUsersServer) GetTeamMember(context.Context, *Id) (*GetTeamMemberResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeamMember not implemented")
}
func (UnimplementedUsersServer) GetTeamMembers(*emptypb.Empty, grpc.ServerStreamingServer[ListTeamMembersResponse]) error {
	return status.Errorf(codes.Unimplemented, "method GetTeamMembers not implemented")
}
func (UnimplementedUsersServer) DeleteTeamMember(context.Context, *Id) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTeamMember not implemented")
}
func (UnimplementedUsersServer) GetTeamMemberLogs(*AuditLogRequest, grpc.ServerStreamingServer[AuditLog]) error {
	return status.Errorf(codes.Unimplemented, "method GetTeamMemberLogs not implemented")
}
func (UnimplementedUsersServer) testEmbeddedByValue() {}

// UnsafeUsersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UsersServer will
// result in compilation errors.
type UnsafeUsersServer interface {
	mustEmbedUnimplementedUsersServer()
}

func RegisterUsersServer(s grpc.ServiceRegistrar, srv UsersServer) {
	// If the following call pancis, it indicates UnimplementedUsersServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Users_ServiceDesc, srv)
}

func _Users_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreateUser(ctx, req.(*NewUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_NewUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).NewUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_NewUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).NewUser(ctx, req.(*NewUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_Verify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).Verify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_Verify_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).Verify(ctx, req.(*VerifyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ResendVerificationEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ResendVerificationEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_ResendVerificationEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ResendVerificationEmail(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetUser(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).Login(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_Get2FaBarcode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).Get2FaBarcode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_Get2FaBarcode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).Get2FaBarcode(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ResetPassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Credentials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ResetPassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_ResetPassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ResetPassword(ctx, req.(*Credentials))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_SendPasswordResetLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Username)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).SendPasswordResetLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_SendPasswordResetLink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).SendPasswordResetLink(ctx, req.(*Username))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ChangePassword_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PasswordResetInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ChangePassword(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_ChangePassword_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ChangePassword(ctx, req.(*PasswordResetInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ChangeEmail_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Email)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ChangeEmail(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_ChangeEmail_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ChangeEmail(ctx, req.(*Email))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_ConfirmEmailChange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfirmEmailChangeInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).ConfirmEmailChange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_ConfirmEmailChange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).ConfirmEmailChange(ctx, req.(*ConfirmEmailChangeInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_UpdateCompanyName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompanyName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).UpdateCompanyName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_UpdateCompanyName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).UpdateCompanyName(ctx, req.(*CompanyName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetProjectsForUserQueryDeprecated_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsForUserQueryDeprecated(m, &grpc.GenericServerStream[Pagination, Project]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsForUserQueryDeprecatedServer = grpc.ServerStreamingServer[Project]

func _Users_GetProjectsQueryDeprecated_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Pagination)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsQueryDeprecated(m, &grpc.GenericServerStream[Pagination, Project]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsQueryDeprecatedServer = grpc.ServerStreamingServer[Project]

func _Users_GetProjectsForUserQuery_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Filters)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsForUserQuery(m, &grpc.GenericServerStream[Filters, Project]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsForUserQueryServer = grpc.ServerStreamingServer[Project]

func _Users_GetProjectsQuery_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Filters)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsQuery(m, &grpc.GenericServerStream[Filters, Project]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsQueryServer = grpc.ServerStreamingServer[Project]

func _Users_GetProjectByUuid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetProjectByUuid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_GetProjectByUuid_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetProjectByUuid(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetProjectAndTemplateByShortCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetProjectAndTemplateByShortCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_GetProjectAndTemplateByShortCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetProjectAndTemplateByShortCode(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetProjectsForUser_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectStatusFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjectsForUser(m, &grpc.GenericServerStream[ProjectStatusFilter, Project]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsForUserServer = grpc.ServerStreamingServer[Project]

func _Users_GetProjects_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ProjectStatusFilter)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetProjects(m, &grpc.GenericServerStream[ProjectStatusFilter, Project]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetProjectsServer = grpc.ServerStreamingServer[Project]

func _Users_GetScannerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetScannerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_GetScannerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetScannerConfig(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_CreateScannerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScannerConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreateScannerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_CreateScannerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreateScannerConfig(ctx, req.(*ScannerConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_UpdateScannerConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ScannerConfiguration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).UpdateScannerConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_UpdateScannerConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).UpdateScannerConfig(ctx, req.(*ScannerConfiguration))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_CreateAuthorizationResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OAuth2AuthorizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreateAuthorizationResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_CreateAuthorizationResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreateAuthorizationResource(ctx, req.(*OAuth2AuthorizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_DeleteAuthorizationResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).DeleteAuthorizationResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_DeleteAuthorizationResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).DeleteAuthorizationResource(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_RefreshApiSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).RefreshApiSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_RefreshApiSecret_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).RefreshApiSecret(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_DeleteAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).DeleteAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_DeleteAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).DeleteAccount(ctx, req.(*DeleteAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_RevokeLegacyCredentials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).RevokeLegacyCredentials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_RevokeLegacyCredentials_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).RevokeLegacyCredentials(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_CreateTeamMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewTeamMember)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreateTeamMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_CreateTeamMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreateTeamMember(ctx, req.(*NewTeamMember))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_CreatePermissionsForTeamMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TeamMemberPermissions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).CreatePermissionsForTeamMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_CreatePermissionsForTeamMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).CreatePermissionsForTeamMember(ctx, req.(*TeamMemberPermissions))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_UpdateTeamMemberPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TeamMemberPermissions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).UpdateTeamMemberPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_UpdateTeamMemberPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).UpdateTeamMemberPermissions(ctx, req.(*TeamMemberPermissions))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_PatchTeamMemberPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TeamMemberPermissions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).PatchTeamMemberPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_PatchTeamMemberPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).PatchTeamMemberPermissions(ctx, req.(*TeamMemberPermissions))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetTeamMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).GetTeamMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_GetTeamMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).GetTeamMember(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetTeamMembers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetTeamMembers(m, &grpc.GenericServerStream[emptypb.Empty, ListTeamMembersResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetTeamMembersServer = grpc.ServerStreamingServer[ListTeamMembersResponse]

func _Users_DeleteTeamMember_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UsersServer).DeleteTeamMember(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Users_DeleteTeamMember_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UsersServer).DeleteTeamMember(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Users_GetTeamMemberLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AuditLogRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UsersServer).GetTeamMemberLogs(m, &grpc.GenericServerStream[AuditLogRequest, AuditLog]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Users_GetTeamMemberLogsServer = grpc.ServerStreamingServer[AuditLog]

// Users_ServiceDesc is the grpc.ServiceDesc for Users service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Users_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createUser",
			Handler:    _Users_CreateUser_Handler,
		},
		{
			MethodName: "newUser",
			Handler:    _Users_NewUser_Handler,
		},
		{
			MethodName: "verify",
			Handler:    _Users_Verify_Handler,
		},
		{
			MethodName: "resendVerificationEmail",
			Handler:    _Users_ResendVerificationEmail_Handler,
		},
		{
			MethodName: "getUser",
			Handler:    _Users_GetUser_Handler,
		},
		{
			MethodName: "login",
			Handler:    _Users_Login_Handler,
		},
		{
			MethodName: "get2faBarcode",
			Handler:    _Users_Get2FaBarcode_Handler,
		},
		{
			MethodName: "resetPassword",
			Handler:    _Users_ResetPassword_Handler,
		},
		{
			MethodName: "sendPasswordResetLink",
			Handler:    _Users_SendPasswordResetLink_Handler,
		},
		{
			MethodName: "changePassword",
			Handler:    _Users_ChangePassword_Handler,
		},
		{
			MethodName: "changeEmail",
			Handler:    _Users_ChangeEmail_Handler,
		},
		{
			MethodName: "confirmEmailChange",
			Handler:    _Users_ConfirmEmailChange_Handler,
		},
		{
			MethodName: "updateCompanyName",
			Handler:    _Users_UpdateCompanyName_Handler,
		},
		{
			MethodName: "getProjectByUuid",
			Handler:    _Users_GetProjectByUuid_Handler,
		},
		{
			MethodName: "getProjectAndTemplateByShortCode",
			Handler:    _Users_GetProjectAndTemplateByShortCode_Handler,
		},
		{
			MethodName: "getScannerConfig",
			Handler:    _Users_GetScannerConfig_Handler,
		},
		{
			MethodName: "createScannerConfig",
			Handler:    _Users_CreateScannerConfig_Handler,
		},
		{
			MethodName: "updateScannerConfig",
			Handler:    _Users_UpdateScannerConfig_Handler,
		},
		{
			MethodName: "createAuthorizationResource",
			Handler:    _Users_CreateAuthorizationResource_Handler,
		},
		{
			MethodName: "deleteAuthorizationResource",
			Handler:    _Users_DeleteAuthorizationResource_Handler,
		},
		{
			MethodName: "refreshApiSecret",
			Handler:    _Users_RefreshApiSecret_Handler,
		},
		{
			MethodName: "deleteAccount",
			Handler:    _Users_DeleteAccount_Handler,
		},
		{
			MethodName: "revokeLegacyCredentials",
			Handler:    _Users_RevokeLegacyCredentials_Handler,
		},
		{
			MethodName: "createTeamMember",
			Handler:    _Users_CreateTeamMember_Handler,
		},
		{
			MethodName: "createPermissionsForTeamMember",
			Handler:    _Users_CreatePermissionsForTeamMember_Handler,
		},
		{
			MethodName: "updateTeamMemberPermissions",
			Handler:    _Users_UpdateTeamMemberPermissions_Handler,
		},
		{
			MethodName: "patchTeamMemberPermissions",
			Handler:    _Users_PatchTeamMemberPermissions_Handler,
		},
		{
			MethodName: "getTeamMember",
			Handler:    _Users_GetTeamMember_Handler,
		},
		{
			MethodName: "deleteTeamMember",
			Handler:    _Users_DeleteTeamMember_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "getProjectsForUserQueryDeprecated",
			Handler:       _Users_GetProjectsForUserQueryDeprecated_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjectsQueryDeprecated",
			Handler:       _Users_GetProjectsQueryDeprecated_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjectsForUserQuery",
			Handler:       _Users_GetProjectsForUserQuery_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjectsQuery",
			Handler:       _Users_GetProjectsQuery_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjectsForUser",
			Handler:       _Users_GetProjectsForUser_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getProjects",
			Handler:       _Users_GetProjects_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getTeamMembers",
			Handler:       _Users_GetTeamMembers_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "getTeamMemberLogs",
			Handler:       _Users_GetTeamMemberLogs_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc_others.proto",
}

const (
	Integrations_CreateIntegrations_FullMethodName              = "/io.Integrations/createIntegrations"
	Integrations_GetIntegrations_FullMethodName                 = "/io.Integrations/getIntegrations"
	Integrations_UpdateIntegrations_FullMethodName              = "/io.Integrations/updateIntegrations"
	Integrations_DeleteIntegrations_FullMethodName              = "/io.Integrations/deleteIntegrations"
	Integrations_CreateSinkSubscription_FullMethodName          = "/io.Integrations/createSinkSubscription"
	Integrations_GetSinkSubscription_FullMethodName             = "/io.Integrations/getSinkSubscription"
	Integrations_ListSinkSubscriptionsDeprecated_FullMethodName = "/io.Integrations/listSinkSubscriptionsDeprecated"
	Integrations_ListSinkSubscriptions_FullMethodName           = "/io.Integrations/listSinkSubscriptions"
	Integrations_UpdateSinkSubscription_FullMethodName          = "/io.Integrations/updateSinkSubscription"
	Integrations_DeleteSinkSubscription_FullMethodName          = "/io.Integrations/deleteSinkSubscription"
	Integrations_GetSampleSubscriptionEvent_FullMethodName      = "/io.Integrations/getSampleSubscriptionEvent"
	Integrations_CallDynamicApi_FullMethodName                  = "/io.Integrations/callDynamicApi"
)

// IntegrationsClient is the client API for Integrations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type IntegrationsClient interface {
	CreateIntegrations(ctx context.Context, in *IntegrationConfigs, opts ...grpc.CallOption) (*Id, error)
	GetIntegrations(ctx context.Context, in *ProtocolIdInput, opts ...grpc.CallOption) (*IntegrationConfigs, error)
	UpdateIntegrations(ctx context.Context, in *IntegrationConfigs, opts ...grpc.CallOption) (*Id, error)
	DeleteIntegrations(ctx context.Context, in *ProtocolIdInput, opts ...grpc.CallOption) (*emptypb.Empty, error)
	CreateSinkSubscription(ctx context.Context, in *SinkSubscription, opts ...grpc.CallOption) (*Id, error)
	GetSinkSubscription(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (*SinkSubscription, error)
	ListSinkSubscriptionsDeprecated(ctx context.Context, in *ListRequestDeprecated, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SinkSubscription], error)
	ListSinkSubscriptions(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SinkSubscription], error)
	UpdateSinkSubscription(ctx context.Context, in *SinkSubscription, opts ...grpc.CallOption) (*Id, error)
	DeleteSinkSubscription(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	GetSampleSubscriptionEvent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SinkSubscription, error)
	CallDynamicApi(ctx context.Context, in *DynamicApiInput, opts ...grpc.CallOption) (*DynamicApiResponse, error)
}

type integrationsClient struct {
	cc grpc.ClientConnInterface
}

func NewIntegrationsClient(cc grpc.ClientConnInterface) IntegrationsClient {
	return &integrationsClient{cc}
}

func (c *integrationsClient) CreateIntegrations(ctx context.Context, in *IntegrationConfigs, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, Integrations_CreateIntegrations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) GetIntegrations(ctx context.Context, in *ProtocolIdInput, opts ...grpc.CallOption) (*IntegrationConfigs, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IntegrationConfigs)
	err := c.cc.Invoke(ctx, Integrations_GetIntegrations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) UpdateIntegrations(ctx context.Context, in *IntegrationConfigs, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, Integrations_UpdateIntegrations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) DeleteIntegrations(ctx context.Context, in *ProtocolIdInput, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Integrations_DeleteIntegrations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) CreateSinkSubscription(ctx context.Context, in *SinkSubscription, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, Integrations_CreateSinkSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) GetSinkSubscription(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (*SinkSubscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SinkSubscription)
	err := c.cc.Invoke(ctx, Integrations_GetSinkSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) ListSinkSubscriptionsDeprecated(ctx context.Context, in *ListRequestDeprecated, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SinkSubscription], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Integrations_ServiceDesc.Streams[0], Integrations_ListSinkSubscriptionsDeprecated_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListRequestDeprecated, SinkSubscription]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Integrations_ListSinkSubscriptionsDeprecatedClient = grpc.ServerStreamingClient[SinkSubscription]

func (c *integrationsClient) ListSinkSubscriptions(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SinkSubscription], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Integrations_ServiceDesc.Streams[1], Integrations_ListSinkSubscriptions_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ListRequest, SinkSubscription]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Integrations_ListSinkSubscriptionsClient = grpc.ServerStreamingClient[SinkSubscription]

func (c *integrationsClient) UpdateSinkSubscription(ctx context.Context, in *SinkSubscription, opts ...grpc.CallOption) (*Id, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Id)
	err := c.cc.Invoke(ctx, Integrations_UpdateSinkSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) DeleteSinkSubscription(ctx context.Context, in *SubscriptionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Integrations_DeleteSinkSubscription_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) GetSampleSubscriptionEvent(ctx context.Context, in *Id, opts ...grpc.CallOption) (*SinkSubscription, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SinkSubscription)
	err := c.cc.Invoke(ctx, Integrations_GetSampleSubscriptionEvent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *integrationsClient) CallDynamicApi(ctx context.Context, in *DynamicApiInput, opts ...grpc.CallOption) (*DynamicApiResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DynamicApiResponse)
	err := c.cc.Invoke(ctx, Integrations_CallDynamicApi_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IntegrationsServer is the server API for Integrations service.
// All implementations should embed UnimplementedIntegrationsServer
// for forward compatibility.
type IntegrationsServer interface {
	CreateIntegrations(context.Context, *IntegrationConfigs) (*Id, error)
	GetIntegrations(context.Context, *ProtocolIdInput) (*IntegrationConfigs, error)
	UpdateIntegrations(context.Context, *IntegrationConfigs) (*Id, error)
	DeleteIntegrations(context.Context, *ProtocolIdInput) (*emptypb.Empty, error)
	CreateSinkSubscription(context.Context, *SinkSubscription) (*Id, error)
	GetSinkSubscription(context.Context, *SubscriptionRequest) (*SinkSubscription, error)
	ListSinkSubscriptionsDeprecated(*ListRequestDeprecated, grpc.ServerStreamingServer[SinkSubscription]) error
	ListSinkSubscriptions(*ListRequest, grpc.ServerStreamingServer[SinkSubscription]) error
	UpdateSinkSubscription(context.Context, *SinkSubscription) (*Id, error)
	DeleteSinkSubscription(context.Context, *SubscriptionRequest) (*emptypb.Empty, error)
	GetSampleSubscriptionEvent(context.Context, *Id) (*SinkSubscription, error)
	CallDynamicApi(context.Context, *DynamicApiInput) (*DynamicApiResponse, error)
}

// UnimplementedIntegrationsServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedIntegrationsServer struct{}

func (UnimplementedIntegrationsServer) CreateIntegrations(context.Context, *IntegrationConfigs) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateIntegrations not implemented")
}
func (UnimplementedIntegrationsServer) GetIntegrations(context.Context, *ProtocolIdInput) (*IntegrationConfigs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegrations not implemented")
}
func (UnimplementedIntegrationsServer) UpdateIntegrations(context.Context, *IntegrationConfigs) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateIntegrations not implemented")
}
func (UnimplementedIntegrationsServer) DeleteIntegrations(context.Context, *ProtocolIdInput) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteIntegrations not implemented")
}
func (UnimplementedIntegrationsServer) CreateSinkSubscription(context.Context, *SinkSubscription) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSinkSubscription not implemented")
}
func (UnimplementedIntegrationsServer) GetSinkSubscription(context.Context, *SubscriptionRequest) (*SinkSubscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSinkSubscription not implemented")
}
func (UnimplementedIntegrationsServer) ListSinkSubscriptionsDeprecated(*ListRequestDeprecated, grpc.ServerStreamingServer[SinkSubscription]) error {
	return status.Errorf(codes.Unimplemented, "method ListSinkSubscriptionsDeprecated not implemented")
}
func (UnimplementedIntegrationsServer) ListSinkSubscriptions(*ListRequest, grpc.ServerStreamingServer[SinkSubscription]) error {
	return status.Errorf(codes.Unimplemented, "method ListSinkSubscriptions not implemented")
}
func (UnimplementedIntegrationsServer) UpdateSinkSubscription(context.Context, *SinkSubscription) (*Id, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSinkSubscription not implemented")
}
func (UnimplementedIntegrationsServer) DeleteSinkSubscription(context.Context, *SubscriptionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSinkSubscription not implemented")
}
func (UnimplementedIntegrationsServer) GetSampleSubscriptionEvent(context.Context, *Id) (*SinkSubscription, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSampleSubscriptionEvent not implemented")
}
func (UnimplementedIntegrationsServer) CallDynamicApi(context.Context, *DynamicApiInput) (*DynamicApiResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallDynamicApi not implemented")
}
func (UnimplementedIntegrationsServer) testEmbeddedByValue() {}

// UnsafeIntegrationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to IntegrationsServer will
// result in compilation errors.
type UnsafeIntegrationsServer interface {
	mustEmbedUnimplementedIntegrationsServer()
}

func RegisterIntegrationsServer(s grpc.ServiceRegistrar, srv IntegrationsServer) {
	// If the following call pancis, it indicates UnimplementedIntegrationsServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Integrations_ServiceDesc, srv)
}

func _Integrations_CreateIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegrationConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).CreateIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_CreateIntegrations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).CreateIntegrations(ctx, req.(*IntegrationConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_GetIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtocolIdInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).GetIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_GetIntegrations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).GetIntegrations(ctx, req.(*ProtocolIdInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_UpdateIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IntegrationConfigs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).UpdateIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_UpdateIntegrations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).UpdateIntegrations(ctx, req.(*IntegrationConfigs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_DeleteIntegrations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProtocolIdInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).DeleteIntegrations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_DeleteIntegrations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).DeleteIntegrations(ctx, req.(*ProtocolIdInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_CreateSinkSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SinkSubscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).CreateSinkSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_CreateSinkSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).CreateSinkSubscription(ctx, req.(*SinkSubscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_GetSinkSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).GetSinkSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_GetSinkSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).GetSinkSubscription(ctx, req.(*SubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_ListSinkSubscriptionsDeprecated_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListRequestDeprecated)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IntegrationsServer).ListSinkSubscriptionsDeprecated(m, &grpc.GenericServerStream[ListRequestDeprecated, SinkSubscription]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Integrations_ListSinkSubscriptionsDeprecatedServer = grpc.ServerStreamingServer[SinkSubscription]

func _Integrations_ListSinkSubscriptions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(IntegrationsServer).ListSinkSubscriptions(m, &grpc.GenericServerStream[ListRequest, SinkSubscription]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Integrations_ListSinkSubscriptionsServer = grpc.ServerStreamingServer[SinkSubscription]

func _Integrations_UpdateSinkSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SinkSubscription)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).UpdateSinkSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_UpdateSinkSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).UpdateSinkSubscription(ctx, req.(*SinkSubscription))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_DeleteSinkSubscription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubscriptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).DeleteSinkSubscription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_DeleteSinkSubscription_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).DeleteSinkSubscription(ctx, req.(*SubscriptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_GetSampleSubscriptionEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Id)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).GetSampleSubscriptionEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_GetSampleSubscriptionEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).GetSampleSubscriptionEvent(ctx, req.(*Id))
	}
	return interceptor(ctx, in, info, handler)
}

func _Integrations_CallDynamicApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DynamicApiInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IntegrationsServer).CallDynamicApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Integrations_CallDynamicApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IntegrationsServer).CallDynamicApi(ctx, req.(*DynamicApiInput))
	}
	return interceptor(ctx, in, info, handler)
}

// Integrations_ServiceDesc is the grpc.ServiceDesc for Integrations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Integrations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "io.Integrations",
	HandlerType: (*IntegrationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "createIntegrations",
			Handler:    _Integrations_CreateIntegrations_Handler,
		},
		{
			MethodName: "getIntegrations",
			Handler:    _Integrations_GetIntegrations_Handler,
		},
		{
			MethodName: "updateIntegrations",
			Handler:    _Integrations_UpdateIntegrations_Handler,
		},
		{
			MethodName: "deleteIntegrations",
			Handler:    _Integrations_DeleteIntegrations_Handler,
		},
		{
			MethodName: "createSinkSubscription",
			Handler:    _Integrations_CreateSinkSubscription_Handler,
		},
		{
			MethodName: "getSinkSubscription",
			Handler:    _Integrations_GetSinkSubscription_Handler,
		},
		{
			MethodName: "updateSinkSubscription",
			Handler:    _Integrations_UpdateSinkSubscription_Handler,
		},
		{
			MethodName: "deleteSinkSubscription",
			Handler:    _Integrations_DeleteSinkSubscription_Handler,
		},
		{
			MethodName: "getSampleSubscriptionEvent",
			Handler:    _Integrations_GetSampleSubscriptionEvent_Handler,
		},
		{
			MethodName: "callDynamicApi",
			Handler:    _Integrations_CallDynamicApi_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "listSinkSubscriptionsDeprecated",
			Handler:       _Integrations_ListSinkSubscriptionsDeprecated_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "listSinkSubscriptions",
			Handler:       _Integrations_ListSinkSubscriptions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "io/core/a_rpc_others.proto",
}
